import json
import os
import requests
import time
from datetime import datetime

# Mapping alte ID → GEN24 Device-ID
SMARTMETER_MAP = {
    "16252931": "Fronius_SmartMeter_2223836ab422",
    "16711682": "Fronius_SmartMeter_4d68ed529a2d"
}

SMARTMETER_IDS = list(SMARTMETER_MAP.keys())

SAVE_FILE = os.path.join(os.path.dirname(__file__), "FremdAPI_last.json")
GEN24_IP = "192.168.178.42"
GEN24_URL = f"http://{GEN24_IP}/components/readable"


# ---------- GEN24 abrufen, mit 3 Retries ----------

def fetch_gen24_data_retry(max_retries=3, pause=0.3):
    """Holt GEN24 JSON mit Retry, um unvollständige Blöcke abzufangen."""
    for attempt in range(1, max_retries + 1):
        try:
            resp = requests.get(GEN24_URL, timeout=5)
            resp.raise_for_status()
            data = resp.json()

            # Prüfen, ob alle Smartmeter-Blöcke da sind
            missing = [
                dev for dev in SMARTMETER_MAP.values()
                if dev not in data
            ]

            if not missing:
                if attempt > 1:
                    print(f"GEN24: Erfolg nach Retry #{attempt}.")
                return data

            print(f"GEN24: Smartmeter fehlen ({missing}) → Retry {attempt}/{max_retries}")
            time.sleep(pause)

        except Exception as e:
            print(f"GEN24: Fehler beim Abrufen (Versuch {attempt}) → {e}")
            time.sleep(pause)

    print("GEN24: ⚠️ Auch nach Retries unvollständig. Nutze übergebene Daten oder Fallback.")
    return None


# ---------- State laden/speichern ----------

def load_state():
    if os.path.exists(SAVE_FILE):
        try:
            with open(SAVE_FILE, "r") as f:
                return json.load(f)
        except:
            pass

    state = {sm: {"MEAN_alt": 0, "SUM_berechnet": 0, "SUM_alt2": 0, "stale_count": 0}
             for sm in SMARTMETER_IDS}
    state["TOTAL_SUM_ALT"] = 0
    return state


def save_state(state):
    with open(SAVE_FILE, "w") as f:
        json.dump(state, f)


# ---------- Hauptfunktion ----------

def get_API(data_from_other_script):
    """
    Jetzt NEU:
    1) Versuch GEN24 direkt → bevorzugt!
    2) Wenn GEN24 JSON unvollständig → nutze übergebene Daten
    """

    state = load_state()
    now = datetime.now()

    # 1) GEN24 direkt abrufen
    print("\n--- STARTE DIREKTABRUF GEN24 ---")
    gen24_data = fetch_gen24_data_retry()

    if gen24_data is None:
        print("GEN24 liefert keine vollständigen Daten → nutze übergebenes 'data'.")
        data = data_from_other_script
    else:
        print("GEN24 Daten OK → nutze Direktdaten.")
        data = gen24_data

    total_mean, total_sum = 0, 0

    for sm_id in SMARTMETER_IDS:
        dev_name = SMARTMETER_MAP[sm_id]
        sm_state = state[sm_id]

        # Struktur prüfen
        if dev_name not in data:
            print(f"SM {sm_id}: ❌ Device '{dev_name}' NICHT im verwendeten JSON!")
            print(f"→ Fallback: Werte werden NICHT aktualisiert.")
            continue

        channels = data[dev_name]["channels"]

        # sm_mean
        sm_mean = int(channels.get("SMARTMETER_POWERACTIVE_MEAN_SUM_F64", sm_state["MEAN_alt"]))

        # sm_sum
        sm_sum = int(channels.get("SMARTMETER_ENERGYACTIVE_PRODUCED_SUM_F64", sm_state["SUM_alt2"]))

        # --- Erste Initialisierung ---
        if sm_state["SUM_berechnet"] == 0:
            print(f"SM {sm_id}: Erste Initialisierung → {sm_sum}")
            sm_state["SUM_berechnet"] = sm_sum
            sm_state["SUM_alt2"] = sm_sum

        # Wertebereich prüfen
        if 0 <= sm_mean < 8000:
            sm_state["MEAN_alt"] = sm_mean
        else:
            sm_mean = sm_state["MEAN_alt"]

        # sm_sum Plausibilität
        plausible_min = min(sm_state["SUM_berechnet"], sm_state["SUM_alt2"]) - 800
        plausible_max = max(sm_state["SUM_berechnet"], sm_state["SUM_alt2"]) + 16000

        if plausible_min <= sm_sum <= plausible_max:
            sm_state["SUM_alt2"] = sm_sum
        else:
            old = sm_sum
            sm_sum = int(max(sm_state["SUM_berechnet"], sm_state["SUM_alt2"]) + sm_mean / 8)
            print(f"SM {sm_id}: ❗ Fehlerhafter Summenwert {old} → Fallback {sm_sum}")

        if sm_sum > sm_state["SUM_berechnet"]:
            sm_state["SUM_berechnet"] = sm_sum

        total_mean += sm_mean
        total_sum += sm_sum

    # Sicherung
    last_total = state["TOTAL_SUM_ALT"]

    if last_total != 0:
        if total_sum < last_total:
            total_sum = last_total
        elif total_sum > last_total + 16000:
            total_sum = last_total + 16000

    state["TOTAL_SUM_ALT"] = total_sum
    save_state(state)

    # API-Ausgabe
    Fremd_API = {
        "aktuellePVProduktion": total_mean,
        "AC_Produktion": total_sum,
        "DC_Produktion": int(total_sum * 1.05),
    }

    print("\n--- ERGEBNIS ---")
    print("GesamtProduktionSM:", Fremd_API["aktuellePVProduktion"])
    print("GesamtEnergieSM:", Fremd_API["AC_Produktion"], "\n")

    return Fremd_API
