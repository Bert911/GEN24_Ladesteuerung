import json
import os
import requests
import time
from datetime import datetime


# >>>>>>>>  Hier Änderungen vornehmen  >>>>>>>>>>>>>>>>>>>>>
# Ganz unten stehen weitere Tipps bei Verbindungs- und Datenproblemen.

INITIAL_TOTAL_ENERGY = 12694835             # EINMALIGER Startwert (manuell setzen)
#                                           Gesamtproduktionswert aller Smartmeter in Wh
#                                           wird als letzte Sicherheit genutzt und nicht aktualisiert


SMARTMETER_DEVICES = [                      # Smartmeter-Device-Namen (neue GEN24-Struktur ab Firmware 1.39.5-1)
    "Fronius_SmartMeter_2223836ab422",      # inkompatibel mit vorheriger Firmware
    "Fronius_SmartMeter_4d68ed529a2d"
]

GEN24_IP = "192.168.178.42"                # IP-Adresse des GEN24
Summenpruefung_aktiv = 1                   # 1 = aktiv, 0 = deakt. (Prüfung mit Startwert bleibt immer erhalten)
Leistung_WR = 7500                         # Leistung des größten Wechselrichters / Smartmeters
Max_Energiesprung = Leistung_WR / 5        # maximal zulässiger Energiesprung pro Abruf/Smartmeter (0 zum deakt.)
Max_Energiesprung_Tag = Leistung_WR * 8    # tägliche Sicherheitsgrenze pro Smartmeter (0 zum deakt.)


# >>>>>>>>  Unterhalb nur bei Bedarf ändern  >>>>>>>>>>>>>>>>>>>>>


SAVE_FILE = os.path.join(os.path.dirname(__file__), "FremdAPI_last.json")
GEN24_URL = f"http://{GEN24_IP}/components/readable"


# ------------------------- Hilfsfunktionen -------------------------

def fetch_gen24_data():
    try:
        response = requests.get(GEN24_URL, timeout=5)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"Fehler beim Abrufen der GEN24-Daten: {e}")
        return {}


def extract_devices_struct(data):
    """
    Datenstruktur aus externem Script prüfen.
    Zulässig:
        data["Body"]["Data"]
        data["Data"]
        direkt data (falls schon vorverarbeitet)
    Gibt die devices-Map (device_name -> {attributes, channels, ...}) zurück.
    """
    if isinstance(data, dict):
        # Fall: komplette API-Antwort mit Body->Data
        if "Body" in data and isinstance(data["Body"], dict) and "Data" in data["Body"]:
            return data["Body"]["Data"]
        # Fall: direktes Data-Feld
        if "Data" in data and isinstance(data["Data"], dict):
            return data["Data"]
        # Wenn dict, aber schon devices
        return data
    return {}


def load_state():
    """State aus Datei laden. Bei Fehlern, leeren Dateien oder veralteter Struktur wird ein neuer State erzeugt.
       TOTAL_SUM_ALT wird automatisch auf einen sicheren Startwert gesetzt."""

    if os.path.exists(SAVE_FILE):
        try:
            with open(SAVE_FILE, "r") as f:
                content = f.read().strip()
                if content == "":
                    print("WARNUNG: FremdAPI_last.json ist leer → neue Struktur wird erzeugt.")
                else:
                    state = json.loads(content)

                    # Datei vorhanden & lesbar → TOTAL_SUM_ALT korrekt initialisieren
                    alt = state.get("TOTAL_SUM_ALT", 0)
                    if alt < INITIAL_TOTAL_ENERGY:
                        print(f"TOTAL_SUM_ALT aktualisiert auf Initialwert {INITIAL_TOTAL_ENERGY}")
                        state["TOTAL_SUM_ALT"] = INITIAL_TOTAL_ENERGY

                    # alle Smartmeter in richtige Struktur bringen
                    changed = False
                    for dev in SMARTMETER_DEVICES:
                        if dev not in state or not isinstance(state.get(dev), dict):
                            print(f"{dev}: alte oder ungültige Struktur → wird neu initialisiert.")
                            state[dev] = {
                                "MEAN_alt": 0,      # letzter gültiger Leistungswert
                                "SUM_berechnet": 0, # berechnete Energiesumme
                                "SUM_alt2": 0,      # letzter echter Zählerstand
                                "stale_count": 0    # unverändert-Zähler
                            }
                            changed = True

                    if changed:
                        print("Strukturfehler korrigiert – State wurde überarbeitet.")

                    return state

        except Exception as e:
            print(f"WARNUNG: JSON defekt ({e}) → neue Struktur wird erzeugt.")

    # Datei fehlt oder defekt → komplett neuer State
    print("Erzeuge neuen State...")
    state = {
        dev: {
            "MEAN_alt": 0,
            "SUM_berechnet": 0,
            "SUM_alt2": 0,
            "stale_count": 0
        }
        for dev in SMARTMETER_DEVICES
    }
    state["TOTAL_SUM_ALT"] = INITIAL_TOTAL_ENERGY
    print(f"TOTAL_SUM_ALT initial auf {INITIAL_TOTAL_ENERGY} gesetzt.")
    return state


def save_state(state):
    try:
        with open(SAVE_FILE, "w") as f:
            json.dump(state, f, indent=4)
    except Exception:
        print("Fehler beim Speichern!")


def reset_counters(state):
    """Setzt die stale_count-Zähler täglich zwischen 00:05 und 00:25 zurück."""

    now = datetime.now()
    if now.hour == 0 and 5 <= now.minute <= 25:
        for dev in SMARTMETER_DEVICES:
            state[dev]["stale_count"] = 0
        print("Tagesreset: stale_count auf 0 gesetzt.")


def try_direct_read(device_name, wait_seconds=60, attempt=1):
    """Versucht einen Direktabruf vom GEN24 (bis zu zwei Versuche).
       Gibt (sm_sum, sm_mean) zurück oder (None, None) bei Fehlschlag."""

    if wait_seconds > 0:
        print(f"{device_name}: Warte {wait_seconds}s vor Direktabruf (Versuch {attempt})...")
        time.sleep(wait_seconds)

    fresh = fetch_gen24_data()
    devices = extract_devices_struct(fresh)

    try:
        # robuster Zugriff: falls device nicht vorhanden -> KeyError -> except
        channels = devices[device_name]["channels"]

        sm_sum_raw = channels.get("SMARTMETER_ENERGYACTIVE_PRODUCED_SUM_F64")
        sm_mean_raw = channels.get("SMARTMETER_POWERACTIVE_MEAN_SUM_F64", 0)

        # Wenn sm_sum_raw None -> Fehler provozieren und except auslösen
        if sm_sum_raw is None:
            raise KeyError(f"{device_name}: fehlender Kanal SMARTMETER_ENERGYACTIVE_PRODUCED_SUM_F64")

        sm_sum = int(sm_sum_raw)
        sm_mean = int(sm_mean_raw)

        print(f"{device_name}: Direktabruf erfolgreich (Versuch {attempt})")
        return sm_sum, sm_mean

    except Exception as e:
        print(f"{device_name}: Direktabruf fehlgeschlagen (Versuch {attempt}) → {e}")
        return None, None


# ------------------------- Hauptfunktion -------------------------

def get_API(data):
    state = load_state()
    reset_counters(state)
    now = datetime.now()

    total_mean = 0
    total_sum = 0

    # Geräte-Map aus der übergebenen Struktur extrahieren (robust gegenüber unterschiedlichen Formen)
    devices = extract_devices_struct(data)

    for device_name in SMARTMETER_DEVICES:
        sm_state = state[device_name]

        # ----------- Zugriff auf übergebene Data-Struktur -----------
        try:
            sm_data = devices.get(device_name, {})
            channels = sm_data.get("channels", {}) if isinstance(sm_data, dict) else {}
        except Exception as e:
            print(f"{device_name}: Strukturfehler in externer Data → {e}")
            channels = {}
        # -------------------------------------------------------------

        # Werte einlesen
        sm_mean = None
        sm_sum = None

        # ---------- Daten lesen ----------
        try:
            # Leistung (Mean) — falls nicht vorhanden, bleibt None
            sm_mean_raw = channels.get("SMARTMETER_POWERACTIVE_MEAN_SUM_F64", None)
            if sm_mean_raw is not None:
                sm_mean = int(sm_mean_raw)
        except Exception:
            sm_mean = None

        try:
            # Energie (Sum) — exakter Key erwartet; wenn fehlt -> None
            sm_sum_raw = channels.get("SMARTMETER_ENERGYACTIVE_PRODUCED_SUM_F64", None)
            if sm_sum_raw is not None:
                sm_sum = int(sm_sum_raw)
        except Exception:
            sm_sum = None

        # Wenn Summe fehlt → Direktabruf GEN24 (max. 2 Versuche)
        if sm_sum is None:
            sm_sum, sm_mean = try_direct_read(device_name, wait_seconds=20, attempt=1)
        if sm_sum is None:
            sm_sum, sm_mean = try_direct_read(device_name, wait_seconds=20, attempt=2)

        # Wenn immer noch kein Wert → Fallback auf gespeicherten State
        if sm_sum is None:
            print(f"{device_name}: Fallback genutzt – alte Werte.")
            sm_sum = sm_state.get("SUM_alt2", 0)
            sm_mean = sm_state.get("MEAN_alt", 0)

        # ---------- Erste Initialisierung ----------
        if sm_state["SUM_berechnet"] == 0 and sm_state["SUM_alt2"] == 0:
            print(f"{device_name}: Erste Initialisierung → {sm_sum}")
            sm_state["SUM_berechnet"] = sm_sum
            sm_state["SUM_alt2"] = sm_sum

        # ---------- Stale Detection ----------
        if sm_sum == sm_state["SUM_alt2"] and 8 <= now.hour < 18:
            sm_state["stale_count"] += 1
            print(f"{device_name}: unverändert, Zähler = {sm_state['stale_count']}")
            # sm_mean kann 0 sein; Division int ok
            sm_sum = int(sm_state["SUM_berechnet"] + (sm_mean or 0) / 8)
            sm_state["SUM_berechnet"] = sm_sum

        # ---------- MEAN Prüfung ----------
        if sm_mean is not None and 0 <= sm_mean < Leistung_WR:
            sm_state["MEAN_alt"] = sm_mean
        else:
            print(f"{device_name}: Fehler Produktionswert ({sm_mean}), nutze alten Wert.")
            sm_mean = sm_state["MEAN_alt"]

        # ---------- Summenprüfung ----------
        if Summenpruefung_aktiv:
            min_val = min(sm_state["SUM_berechnet"], sm_state["SUM_alt2"])
            max_val = max(sm_state["SUM_berechnet"], sm_state["SUM_alt2"])

            if min_val <= sm_sum <= (max_val + Leistung_WR * 2):
                sm_state["SUM_alt2"] = sm_sum
            elif (min_val - 800) <= sm_sum:
                sm_sum = int(max_val)
            else:
                old = sm_sum
                sm_sum = int(max_val + sm_state["MEAN_alt"] / 8)
                print(f"{device_name}: Fehler Summenwert ({old}) → Fallback {sm_sum}")

        # ---------- SUM_berechnet aktualisieren ----------
        if sm_sum > sm_state["SUM_berechnet"]:
            sm_state["SUM_berechnet"] = sm_sum

        total_mean += sm_mean
        total_sum += sm_sum

# ---------------------- Gesamt-Sicherheitslogik ----------------------

    last_total = state.get("TOTAL_SUM_ALT", 0)

    if Summenpruefung_aktiv:
        if last_total == 0:
            print(f"Erster Start → TOTAL_SUM_ALT = {total_sum}")

        elif total_sum < last_total:
            print(f"⚠️ Gesamtenergie rückläufig ({total_sum} < {last_total}) → nutze alten Wert.")
            total_sum = last_total

        # ----------- Tagesgrenze (Max_Energiesprung_Tag) -----------
        elif Max_Energiesprung_Tag > 0 and total_sum > last_total + 32000:
            diff = total_sum - last_total
            print(f"⚠️ Gesamtenergie-Sprung viel zu groß (+{diff} Wh, maximal erlaubt +{Max_Energiesprung_Tag} Wh) → verworfen.")
            total_sum = last_total

        # ----------- Einzelabrufgrenze (Max_Energiesprung) -----------
        elif Max_Energiesprung > 0 and total_sum > last_total + 1600:
            diff = total_sum - last_total
            print(
                f"⚠️ Gesamtenergie-Sprung moderat groß (+{diff} Wh, maximal erlaubt +{Max_Energiesprung} Wh) "
                f"→ begrenzt auf +{Max_Energiesprung} Wh."
            )
            total_sum = last_total + 1600

    state["TOTAL_SUM_ALT"] = total_sum
    save_state(state)

    # ---------------------- Ausgabe ----------------------

    if INITIAL_TOTAL_ENERGY > total_sum:
        total_sum=INITIAL_TOTAL_ENERGY
        print(f"⚠️ Datenfehler: AC_Produktion aktualisiert auf Initialwert {INITIAL_TOTAL_ENERGY}")
        print(f"⚠️ Bitte Summenpruefung in den Einstellungen aktivieren")
        print(f"Eine kleine Hilfe ist am Ende des Fremd_API Skriptes")

    Fremd_API = {
        "aktuellePVProduktion": total_mean,
        "AC_Produktion": total_sum,
        "DC_Produktion": int(total_sum * 1.05)
    }

    print("\nGesamtProduktionSM:", Fremd_API["aktuellePVProduktion"])
    print("GesamtEnergieSM:", Fremd_API["AC_Produktion"], "\n")

    return Fremd_API
"""
Empfehlungen bei Verbindungsproblemen:

Die Standard-Einstellung der OpenDTU sollte sein, dass diese nur sendet,
wenn alle Wechselrichter der DTU eine aktive Verbindung haben.
--> unter Netzwerkeinstellungen->Modbus-Einstellungen:
Modbus TCP Server aktivieren:     aktiv (blau)
Modbus TCP Serverstart verzögern: aktiv (blau)

Falls ein Wechselrichter nicht erreichbar ist, liefert die DTU keine neuen Daten an den Fronius.
Dadurch können positive Energiesprünge entstehen, welche mittels "Max_Energiesprung" begrenzt werden

Bei mir kam es ebenfalls vor, dass die DTU beim Neustart zu wenig bisher produzierte Energie
an den Fronius übertragen hat, was in der Historie für Chaos gesorgt hatte.

Im Zweifelsfall schalte ich den GEN24 kurz ab (oder trenne ihn vom Netzwerk).
Solange der GEN24 offline ist, erhält er keine (fehlerhaften) Daten der DTU.
Wenn die DTU und alle Wechselrichter wieder stabil laufen, kann der GEN24 wieder online gehen.

Die Sendeleistung der DTU zu verändern brachte bei mir nur geringfügige Verbesserungen.
Viel entscheidender waren die Positionierung der DTU und die Ausrichtung der Antenne.

Bei mehr als drei Wechselrichtern an einer DTU empfehle ich eine zweite DTU.
Die Kosten sind überschaubar und die Auswirkungen von Datenverlusten halbieren sich.

Die vielen Sicherheitsmechanismen stammen aus der alten GEN24-Firmware (1.38),
bei der der GEN24 teilweise zusätzliche Smartmeter „erfunden“ hat.
Manchmal hat er sogar die beiden IDs vertauscht oder die Werte eines Smartmeters unter beiden IDs ausgegeben.
Damit daraus dennoch eine korrekte Historie entsteht, wurden alle diese Schutzmechanismen eingeführt.

Vielen Dank insbesondere an Wiggal:
https://github.com/wiggal/
"""






