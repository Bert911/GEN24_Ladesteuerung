import json
import os
from datetime import datetime

SAVE_FILE = os.path.join(os.path.dirname(__file__), "FremdAPI_last.json")

SMARTMETER_IDS = ["16252931", "16711682"]  # IDs der Smartmeter


def load_state():
    if os.path.exists(SAVE_FILE):
        try:
            with open(SAVE_FILE, "r") as f:
                return json.load(f)
        except Exception as e:
            print(f"Laden der alten Werte fehlgeschlagen: {e}")
    # Standardwerte
    return {
        sm_id: {
            "MEAN_alt": 0,
            "SUM_berechnet": 0,
            "SUM_alt2": 0,
            "stale_count": 0
        }
        for sm_id in SMARTMETER_IDS
    }


def save_state(state):
    try:
        with open(SAVE_FILE, "w") as f:
            json.dump(state, f)
    except Exception as e:
        print(f"Speichern der Werte fehlgeschlagen: {e}")


def get_API(data):
    state = load_state()
    now = datetime.now()

    # Zähler zwischen 00:05 und 00:25 zurücksetzen
    if now.hour == 0 and 5 <= now.minute <= 25:
        for sm_id in SMARTMETER_IDS:
            state[sm_id]["stale_count"] = 0
        print("Tagesreset: Stale-Counter auf 0 gesetzt")

    total_mean = 0
    total_sum = 0

    for sm_id in SMARTMETER_IDS:
        if sm_id not in state:
            state[sm_id] = {
                "MEAN_alt": 0,
                "SUM_berechnet": 0,
                "SUM_alt2": 0,
                "stale_count": 0
            }

        try:
            channels = data['Body']['Data'][sm_id]['channels']
            API_SM_MEAN = int(channels['SMARTMETER_POWERACTIVE_MEAN_SUM_F64'])
            API_SM_SUM = int(channels['SMARTMETER_ENERGYACTIVE_PRODUCED_SUM_F64'])
        except KeyError:
            print(f"SM {sm_id}: nicht erreichbar")
            continue

        API_SM_SUM_used = API_SM_SUM

        # Wenn Summenwert unverändert ist → hochzählen (nur tagsüber)
        if API_SM_SUM == state[sm_id]["SUM_alt2"]:
            if 8 <= now.hour < 18:
                state[sm_id]["stale_count"] += 1
                print(f"SM {sm_id}: unverändert, Zähler = {state[sm_id]['stale_count']}")
            if state[sm_id]["SUM_berechnet"] != 0:
                API_SM_SUM_used = state[sm_id]["SUM_berechnet"] + (API_SM_MEAN // 6)

        # Neue Logik: nur übernehmen, wenn größer
        if API_SM_SUM <= state[sm_id]["SUM_alt2"]:
            API_SM_SUM_used = state[sm_id]["SUM_berechnet"]
        else:
            state[sm_id]["SUM_alt2"] = API_SM_SUM

        # Zustand aktualisieren (stale_count bleibt bestehen bis Reset)
        state[sm_id]["MEAN_alt"] = API_SM_MEAN
        state[sm_id]["SUM_berechnet"] = API_SM_SUM_used

        total_mean += API_SM_MEAN
        total_sum += API_SM_SUM_used

    save_state(state)

    Fremd_API = {
        'aktuellePVProduktion': int(total_mean),
        'AC_Produktion': int(total_sum),
        'DC_Produktion': int(total_sum * 1.05)
    }

    print("\nGesamtProduktionSM:", Fremd_API['aktuellePVProduktion'])
    print("GesamtEnergieSM:", Fremd_API['AC_Produktion'], "\n")

    return Fremd_API
