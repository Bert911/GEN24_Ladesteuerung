import json
import os
import requests
import time
from datetime import datetime

SMARTMETER_IDS = ["16252931", "16711682"]  # IDs der Smartmeter
SAVE_FILE = os.path.join(os.path.dirname(__file__), "FremdAPI_last.json")
GEN24_IP = "192.168.178.42"
GEN24_URL = f"http://{GEN24_IP}/components/readable"


# ---------- Hilfsfunktionen ----------

def fetch_gen24_data():
    """Lädt die Rohdaten direkt vom GEN24."""
    try:
        response = requests.get(GEN24_URL, timeout=5)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"Fehler beim Abrufen der Daten von GEN24: {e}")
        return {}


def load_state():
    """Lädt den letzten Zustand oder setzt Defaults."""
    if os.path.exists(SAVE_FILE):
        try:
            with open(SAVE_FILE, "r") as f:
                return json.load(f)
        except Exception as e:
            print(f"Laden der alten Werte fehlgeschlagen: {e}")

    # Defaults falls Datei fehlt oder defekt
    state = {
        sm_id: {"MEAN_alt": 0, "SUM_berechnet": 0, "SUM_alt2": 0, "stale_count": 0}
        for sm_id in SMARTMETER_IDS
    }
    state["TOTAL_SUM_ALT"] = 0
    return state


def save_state(state):
    try:
        with open(SAVE_FILE, "w") as f:
            json.dump(state, f)
    except Exception as e:
        print(f"Speichern der Werte fehlgeschlagen: {e}")


def reset_counters(state):
    """Setzt Zähler täglich zwischen 00:05 und 00:25 zurück."""
    now = datetime.now()
    if now.hour == 0 and 5 <= now.minute <= 25:
        for sm in state.values():
            if isinstance(sm, dict):  # nur echte Smartmeter, nicht TOTAL_SUM_ALT
                sm["stale_count"] = 0
        print("Tagesreset: Stale-Counter auf 0 gesetzt")


def try_direct_read(sm_id, wait_seconds=15, attempt=1):
    """Versucht einen Direktabruf vom GEN24 für ein Smartmeter."""
    if wait_seconds > 0:
        print(f"SM {sm_id}: Warte {wait_seconds} Sekunden vor Direktabruf (Versuch {attempt})...")
        time.sleep(wait_seconds)

    fresh_data = fetch_gen24_data()
    try:
        body = fresh_data["Body"]
        body_data = body["Data"]
        sm_data = body_data[sm_id]
        channels = sm_data["channels"]
        sm_sum = int(channels["SMARTMETER_ENERGYACTIVE_PRODUCED_SUM_F64"])
        sm_mean = int(channels.get("SMARTMETER_POWERACTIVE_MEAN_SUM_F64", 0))
        print(f"SM {sm_id}: Direktabruf erfolgreich (Versuch {attempt}).")
        return sm_sum, sm_mean
    except Exception as e:
        print(f"SM {sm_id}: Direktabruf fehlgeschlagen (Versuch {attempt}) → {e}")
        return None, None


# ---------- Hauptfunktion ----------

def get_API(data):
    state = load_state()
    reset_counters(state)
    now = datetime.now()

    total_mean, total_sum = 0, 0

    for sm_id in SMARTMETER_IDS:
        sm_state = state.setdefault(
            sm_id,
            {"MEAN_alt": 0, "SUM_berechnet": 0, "SUM_alt2": 0, "stale_count": 0}
        )

        # Datenstruktur prüfen
        try:
            body = data["Body"]
            body_data = body["Data"]
            sm_data = body_data[sm_id]
            channels = sm_data["channels"]
        except Exception as e:
            print(f"SM {sm_id}: Strukturfehler in den übergebenen Daten → {e}")
            continue

        # sm_mean lesen
        try:
            sm_mean = int(channels["SMARTMETER_POWERACTIVE_MEAN_SUM_F64"])
        except Exception as e:
            print(f"SM {sm_id}: Fehler bei sm_mean → {e}")
            sm_mean = 0

        # sm_sum lesen
        try:
            sm_sum = int(channels["SMARTMETER_ENERGYACTIVE_PRODUCED_SUM_F64"])
        except Exception as e:
            print(f"SM {sm_id}: Fehler bei sm_sum → {e}. Starte Direktabruf...")
            sm_sum, sm_mean = try_direct_read(sm_id, wait_seconds=15, attempt=1)

            if sm_sum is None:
                sm_sum, sm_mean = try_direct_read(sm_id, wait_seconds=15, attempt=2)

            if sm_sum is None:
                print(f"SM {sm_id}: auch nach 2 Direktabrufen nicht lesbar. Nutze Fallback.")
                sm_sum = sm_state["SUM_alt2"]
                sm_mean = sm_state["MEAN_alt"]

        # --- Erste Initialisierung ---
        if sm_state["SUM_berechnet"] == 0 and sm_state["SUM_alt2"] == 0:
            print(f"SM {sm_id}: Erste Initialisierung → übernehme aktuellen Wert {sm_sum}")
            sm_state["SUM_berechnet"] = sm_sum
            sm_state["SUM_alt2"] = sm_sum

        # Wertebereich für sm_sum prüfen
        if (min(sm_state["SUM_berechnet"], sm_state["SUM_alt2"])
            <= sm_sum
            <= (max(sm_state["SUM_berechnet"], sm_state["SUM_alt2"]) + 8000)):
            sm_state["SUM_alt2"] = sm_sum
        else:
            print(f"SM {sm_id}: Fehler Summenwert ({sm_sum}), nutze Fallback.")
            sm_sum = max(sm_state["SUM_berechnet"], sm_state["SUM_alt2"])

        # Wertebereich für sm_mean prüfen
        if 0 <= sm_mean < 8000:
            sm_state["MEAN_alt"] = sm_mean
        else:
            print(f"SM {sm_id}: Fehler Produktionswert ({sm_mean}), nutze alten Wert.")
            sm_mean = sm_state["MEAN_alt"]

        # SUM_berechnet nur erhöhen, wenn neuer Wert plausibel größer ist
        if sm_sum > sm_state["SUM_berechnet"]:
            sm_state["SUM_berechnet"] = sm_sum

        # Stale-Check tagsüber
        if sm_sum == sm_state["SUM_alt2"] and 8 <= now.hour < 18:
            sm_state["stale_count"] += 1
            print(f"SM {sm_id}: unverändert, Zähler = {sm_state['stale_count']}")
            sm_sum = sm_state["SUM_berechnet"] + sm_mean // 6
            sm_state["SUM_berechnet"] = sm_sum

        total_mean += sm_mean
        total_sum += sm_sum

    # ---- 2. Sicherheit: total_sum Plausibilitätsprüfung ----
    last_total = state.get("TOTAL_SUM_ALT", 0)

    if last_total == 0:
        # Erster Start: aktuellen Wert übernehmen
        print(f"Erster Start erkannt → setze TOTAL_SUM_ALT = {total_sum}")
    elif total_sum < last_total:
        print(f"⚠️ Gesamtenergie rückläufig ({total_sum} < {last_total}), nutze alten Wert.")
        total_sum = last_total
    elif total_sum > last_total + 16000:
        print(f"⚠️ Gesamtenergie-Sprung zu groß (+{total_sum - last_total}), nutze alten Wert.")
        total_sum = last_total

    state["TOTAL_SUM_ALT"] = total_sum
    save_state(state)

    Fremd_API = {
        "aktuellePVProduktion": total_mean,
        "AC_Produktion": total_sum,
        "DC_Produktion": int(total_sum * 1.05),
    }

    print("\nGesamtProduktionSM:", Fremd_API["aktuellePVProduktion"])
    print("GesamtEnergieSM:", Fremd_API["AC_Produktion"], "\n")

    return Fremd_API
