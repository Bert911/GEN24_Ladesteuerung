import json
import os
import requests
import time
from datetime import datetime


# >>>>>>>>  Hier Änderungen vornehmen  >>>>>>>>>>>>>>>>>>>>> ganz unten sind weitere Tipps bei Problemen

INITIAL_TOTAL_ENERGY = 12693598             # EINMALIGER INITIAL-WERT (muss manuell gesetzt werden)Beispielwert in Wh
#                                           Gesamtproduktionswert von allen abzurufenden Smartmetern einfügen

SMARTMETER_DEVICES = [                      # Smartmeter-Device-Namen (nur neue GEN24 Struktur ab FW 1.39.5-1)
    "Fronius_SmartMeter_2223836ab422",
    "Fronius_SmartMeter_4d68ed529a2d"
]

GEN24_IP = "192.168.178.42"                # Gen24 IP Adresse
Summenpruefung_aktiv = 1                   # 1 = an, 0 = aus; Prüfung mit Initialwert am Ende bitte manuel entfernen.
Leistung_WR = 7500                         # Leistung des größten WR/Smartmeter in der Anlage
Max_Energiesprung = Leistung_WR / 5        # pro Abruf
Max_Energiesprung_Tag = Leistung_WR * 8    # Tages-Sicherheit (optional)


# >>>>>>>>  Unterhalb nach Bedarf ändern  >>>>>>>>>>>>>>>>>>>>>


SAVE_FILE = os.path.join(os.path.dirname(__file__), "FremdAPI_last.json")
GEN24_URL = f"http://{GEN24_IP}/components/readable"


# ------------------------- Hilfsfunktionen -------------------------

def fetch_gen24_data():
    try:
        response = requests.get(GEN24_URL, timeout=5)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"Fehler beim Abrufen der GEN24-Daten: {e}")
        return {}


def extract_devices_struct(data):
    """
    Datenstruktur aus externem Script prüfen.
    Zulässig:
        data["Body"]["Data"]
        data["Data"]
        direkt data (falls schon vorverarbeitet)
    Gibt die devices-Map (device_name -> {attributes, channels, ...}) zurück.
    """
    if isinstance(data, dict):
        # Fall: komplette API-Antwort mit Body->Data
        if "Body" in data and isinstance(data["Body"], dict) and "Data" in data["Body"]:
            return data["Body"]["Data"]
        # Fall: direktes Data-Feld
        if "Data" in data and isinstance(data["Data"], dict):
            return data["Data"]
        # Wenn dict, aber schon devices
        return data
    return {}


def load_state():
    """State laden. Bei Fehler/leer/alt → neu anlegen. TOTAL_SUM_ALT wird robust initialisiert."""
    # Datei prüfen
    if os.path.exists(SAVE_FILE):
        try:
            with open(SAVE_FILE, "r") as f:
                content = f.read().strip()
                if content == "":
                    print("WARNUNG: FremdAPI_last.json ist leer → neue Struktur wird erzeugt.")
                else:
                    state = json.loads(content)

                    # Datei vorhanden & lesbar → TOTAL_SUM_ALT korrekt initialisieren
                    alt = state.get("TOTAL_SUM_ALT", 0)
                    if alt < INITIAL_TOTAL_ENERGY:
                        print(f"TOTAL_SUM_ALT aktualisiert auf Initialwert {INITIAL_TOTAL_ENERGY}")
                        state["TOTAL_SUM_ALT"] = INITIAL_TOTAL_ENERGY

                    # alle Smartmeter in richtige Struktur bringen
                    changed = False
                    for dev in SMARTMETER_DEVICES:
                        if dev not in state or not isinstance(state.get(dev), dict):
                            print(f"{dev}: alte oder ungültige Struktur → wird neu initialisiert.")
                            state[dev] = {
                                "MEAN_alt": 0,      # letzter gültiger Leistungswert
                                "SUM_berechnet": 0, # berechnete Energiesumme
                                "SUM_alt2": 0,      # letzter echter Zählerstand
                                "stale_count": 0    # unverändert-Zähler
                            }
                            changed = True

                    if changed:
                        print("Strukturfehler korrigiert – State wurde überarbeitet.")

                    return state

        except Exception as e:
            print(f"WARNUNG: JSON defekt ({e}) → neue Struktur wird erzeugt.")

    # Datei fehlt oder defekt → komplett neuer State
    print("Erzeuge neuen State...")
    state = {
        dev: {
            "MEAN_alt": 0,
            "SUM_berechnet": 0,
            "SUM_alt2": 0,
            "stale_count": 0
        }
        for dev in SMARTMETER_DEVICES
    }
    state["TOTAL_SUM_ALT"] = INITIAL_TOTAL_ENERGY
    print(f"TOTAL_SUM_ALT initial auf {INITIAL_TOTAL_ENERGY} gesetzt.")
    return state


def save_state(state):
    try:
        with open(SAVE_FILE, "w") as f:
            json.dump(state, f, indent=4)
    except Exception:
        print("Fehler beim Speichern!")


def reset_counters(state):
    """Setzt die stale_count Counter täglich zwischen 00:05 und 00:25 zurück."""
    now = datetime.now()
    if now.hour == 0 and 5 <= now.minute <= 25:
        for dev in SMARTMETER_DEVICES:
            state[dev]["stale_count"] = 0
        print("Tagesreset: stale_count auf 0 gesetzt.")


def try_direct_read(device_name, wait_seconds=60, attempt=1):
    """Direktabruf vom GEN24. Gibt (sm_sum, sm_mean) oder (None, None) zurück."""
    if wait_seconds > 0:
        print(f"{device_name}: Warte {wait_seconds}s vor Direktabruf (Versuch {attempt})...")
        time.sleep(wait_seconds)

    fresh = fetch_gen24_data()
    devices = extract_devices_struct(fresh)

    try:
        # robuster Zugriff: falls device nicht vorhanden -> KeyError -> except
        channels = devices[device_name]["channels"]

        sm_sum_raw = channels.get("SMARTMETER_ENERGYACTIVE_PRODUCED_SUM_F64")
        sm_mean_raw = channels.get("SMARTMETER_POWERACTIVE_MEAN_SUM_F64", 0)

        # Wenn sm_sum_raw None -> Fehler provozieren und except auslösen
        if sm_sum_raw is None:
            raise KeyError(f"{device_name}: fehlender Kanal SMARTMETER_ENERGYACTIVE_PRODUCED_SUM_F64")

        sm_sum = int(sm_sum_raw)
        sm_mean = int(sm_mean_raw)

        print(f"{device_name}: Direktabruf erfolgreich (Versuch {attempt})")
        return sm_sum, sm_mean

    except Exception as e:
        print(f"{device_name}: Direktabruf fehlgeschlagen (Versuch {attempt}) → {e}")
        return None, None


# ------------------------- Hauptfunktion -------------------------

def get_API(data):
    state = load_state()
    reset_counters(state)
    now = datetime.now()

    total_mean = 0
    total_sum = 0

    # Geräte-Map aus der übergebenen Struktur extrahieren (robust gegenüber unterschiedlichen Formen)
    devices = extract_devices_struct(data)

    for device_name in SMARTMETER_DEVICES:
        sm_state = state[device_name]

        # ----------- Zugriff auf übergebene Data-Struktur -----------
        try:
            sm_data = devices.get(device_name, {})
            channels = sm_data.get("channels", {}) if isinstance(sm_data, dict) else {}
        except Exception as e:
            print(f"{device_name}: Strukturfehler in externer Data → {e}")
            channels = {}
        # -------------------------------------------------------------

        # Werte einlesen
        sm_mean = None
        sm_sum = None

        # ---------- Daten lesen ----------
        try:
            # Leistung (Mean) — falls nicht vorhanden, bleibt None
            sm_mean_raw = channels.get("SMARTMETER_POWERACTIVE_MEAN_SUM_F64", None)
            if sm_mean_raw is not None:
                sm_mean = int(sm_mean_raw)
        except Exception:
            sm_mean = None

        try:
            # Energie (Sum) — exakter Key erwartet; wenn fehlt -> None
            sm_sum_raw = channels.get("SMARTMETER_ENERGYACTIVE_PRODUCED_SUM_F64", None)
            if sm_sum_raw is not None:
                sm_sum = int(sm_sum_raw)
        except Exception:
            sm_sum = None

        # Wenn Summe fehlt → Direktabruf GEN24 (max. 2 Versuche)
        if sm_sum is None:
            sm_sum, sm_mean = try_direct_read(device_name, wait_seconds=20, attempt=1)
        if sm_sum is None:
            sm_sum, sm_mean = try_direct_read(device_name, wait_seconds=20, attempt=2)

        # Wenn immer noch kein Wert → Fallback auf gespeicherten State
        if sm_sum is None:
            print(f"{device_name}: Fallback genutzt – alte Werte.")
            sm_sum = sm_state.get("SUM_alt2", 0)
            sm_mean = sm_state.get("MEAN_alt", 0)

        # ---------- Erste Initialisierung ----------
        if sm_state["SUM_berechnet"] == 0 and sm_state["SUM_alt2"] == 0:
            print(f"{device_name}: Erste Initialisierung → {sm_sum}")
            sm_state["SUM_berechnet"] = sm_sum
            sm_state["SUM_alt2"] = sm_sum

        # ---------- Stale Detection ----------
        if sm_sum == sm_state["SUM_alt2"] and 8 <= now.hour < 18:
            sm_state["stale_count"] += 1
            print(f"{device_name}: unverändert, Zähler = {sm_state['stale_count']}")
            # sm_mean kann 0 sein; Division int ok
            sm_sum = int(sm_state["SUM_berechnet"] + (sm_mean or 0) / 8)
            sm_state["SUM_berechnet"] = sm_sum

        # ---------- MEAN Prüfung ----------
        if sm_mean is not None and 0 <= sm_mean < Leistung_WR:
            sm_state["MEAN_alt"] = sm_mean
        else:
            print(f"{device_name}: Fehler Produktionswert ({sm_mean}), nutze alten Wert.")
            sm_mean = sm_state["MEAN_alt"]

        # ---------- Summenprüfung ----------
        if Summenpruefung_aktiv:
            min_val = min(sm_state["SUM_berechnet"], sm_state["SUM_alt2"])
            max_val = max(sm_state["SUM_berechnet"], sm_state["SUM_alt2"])

            if min_val <= sm_sum <= (max_val + Leistung_WR * 2):
                sm_state["SUM_alt2"] = sm_sum
            elif (min_val - 800) <= sm_sum:
                sm_sum = int(max_val)
            else:
                old = sm_sum
                sm_sum = int(max_val + sm_state["MEAN_alt"] / 8)
                print(f"{device_name}: Fehler Summenwert ({old}) → Fallback {sm_sum}")

        # ---------- SUM_berechnet aktualisieren ----------
        if sm_sum > sm_state["SUM_berechnet"]:
            sm_state["SUM_berechnet"] = sm_sum

        total_mean += sm_mean
        total_sum += sm_sum

    # ---------------------- Gesamt-Sicherheitslogik ----------------------

    last_total = state.get("TOTAL_SUM_ALT", 0)

    if Summenpruefung_aktiv:
        if last_total == 0:
            print(f"Erster Start → TOTAL_SUM_ALT = {total_sum}")

        elif total_sum < last_total:
            print(f"⚠️ Gesamtenergie rückläufig ({total_sum} < {last_total}) → nutze alten Wert.")
            total_sum = last_total

        elif total_sum > last_total + 32000:
            print(f"⚠️ Gesamtenergie-Sprung zu groß (+{total_sum - last_total}) → verworfen.")
            total_sum = last_total

        elif total_sum > last_total + 1600:
            diff = total_sum - last_total
            print(f"⚠️ Gesamtenergie-Sprung moderat groß (+{diff} Wh, maximal erlaubt +32000 Wh) → begrenzt auf +1600 Wh.")
            total_sum = last_total + 1600

    state["TOTAL_SUM_ALT"] = total_sum
    save_state(state)

    # ---------------------- Ausgabe ----------------------

    if INITIAL_TOTAL_ENERGY > total_sum:
        total_sum=INITIAL_TOTAL_ENERGY
        print(f"⚠️ Datenfehler: AC_Produktion aktualisiert auf Initialwert {INITIAL_TOTAL_ENERGY}")
        print(f"⚠️ Bitte Summenpruefung in den Einstellungen aktivieren")
        print(f"Eine kleine Hilfe ist am Ende des Fremd_API Skriptes")

    Fremd_API = {
        "aktuellePVProduktion": total_mean,
        "AC_Produktion": total_sum,
        "DC_Produktion": int(total_sum * 1.05)
    }

    print("\nGesamtProduktionSM:", Fremd_API["aktuellePVProduktion"])
    print("GesamtEnergieSM:", Fremd_API["AC_Produktion"], "\n")

    return Fremd_API
#*
Empfehlung für Verbindungsfehler:
Die Standardeinstellung der OptenDTU sollte sein, dass dieser nur sendet,
wenn alle Wechselrichter der DTU eine aktive Verbindung haben.
Sollte ein Wechselrichter nicht erreichbar sein, werden von der DTU keine neuen Daten an den Fronius übergeben.
Dadurch können positive Datensprünge entstehen.
Bei mir kam es ebenfalls vor, dass beim Neustart der DTU auch zu wenig Energie an Fronius übermittelt wurde, was es nicht besser macht.

Im zweifelsfall deaktivere ich den GEN24 (ausschalten oder vom Netzwerk trennen), dadurch bekommt er keine Daten mehr von der DTU.
Wenn die DTU und aller WR dann wieder aktiv sind, darf der GEN24 wieder online gehen.

Die Einstellung der Sendeleistung der DTU hat bei mir nur relativ wenig gebracht.
Da war die Position der DTU sowie die ausrichtung der Antenne viel entscheidender.

Bei mehr wie 3 Wechselrichter an einer DTU empfehler ich eine 2. DTU,
die kosten halten sich ja in Grenzen und die Sprünge bei Datenverlust werden gleichzeitig halbiert.

Die vielen Sicherheitsmechanismen kommen von er alten GEN24 Firmware (1.38),
wo der GEN24 einfach manchmal noch ein zusätzliches Smartmeter erfunden hatte.
Manchmal hat er bei mir auch die beiden ID vertauscht oder die Daten eines Smartmeter bei beiden IDs ausgegeben.
Damit ich dann wenigstens eine vernünftige Historie habe, wurden die ganzen Sicherheitsmechanismen eingeführt.

Vielen Dank geht insbesonders an Wiggal
https://github.com/wiggal/
*#






