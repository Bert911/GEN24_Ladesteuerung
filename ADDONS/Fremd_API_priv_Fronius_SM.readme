import json
import os
import requests
import time
from datetime import datetime


# >>>>>>>>  Hier Änderungen vornehmen  >>>>>>>>>>>>>>>>>>>>>
# Ganz unten stehen weitere Tipps bei Verbindungs- und Datenproblemen.

energy_initial_total = 12694835              # EINMALIGER Startwert (manuell setzen)
#                                              Gesamtproduktionswert aller Smartmeter in Wh
#                                              wird als letzte Sicherheit genutzt und nicht aktualisiert


smartmeter_devices = [                       # Smartmeter-Device-Namen (neue GEN24-Struktur ab Firmware 1.39.5-1)
    "Fronius_SmartMeter_2223836ab422",       # inkompatibel mit vorheriger Firmware
    "Fronius_SmartMeter_4d68ed529a2d"
]

GEN24_IP = "192.168.178.42"                  # IP-Adresse des GEN24
Summenpruefung_aktiv = 1                     # 1 = aktiv, 0 = deakt. (Prüfung mit Startwert bleibt immer erhalten)
Leistung_WR = 7500                           # Leistung des größten Wechselrichters / Smartmeters
Max_Energiesprung = Leistung_WR / 5          # maximal zulässiger Energiesprung pro Abruf/Smartmeter (0 zum deakt.)
Max_Energiesprung_Tag = Leistung_WR * 8      # tägliche Sicherheitsgrenze pro Smartmeter (0 zum deakt.)


# >>>>>>>>  Unterhalb nur bei Bedarf ändern  >>>>>>>>>>>>>>>>>>>>>


SAVE_FILE = os.path.join(os.path.dirname(__file__), "FremdAPI_last.json")
GEN24_URL = f"http://{GEN24_IP}/components/readable"


# ------------------------- Hilfsfunktionen -------------------------

def fetch_gen24_data():
    try:
        response = requests.get(GEN24_URL, timeout=5)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"Fehler beim Abrufen der GEN24-Daten: {e}")
        return {}

def extract_devices_struct(raw):             # Extrahiert die Smartmeter-Daten aus der API-Antwort
    if isinstance(raw, dict):
        if "Body" in raw and isinstance(raw["Body"], dict) and "Data" in raw["Body"]:
            return raw["Body"]["Data"]
        if "Data" in raw and isinstance(raw["Data"], dict):
            return raw["Data"]
        return raw
    return {}

def load_state():
    """State aus Datei laden. Bei Fehlern, leeren Dateien oder veralteter Struktur wird ein neuer State erzeugt.
       energy_last_total wird automatisch auf einen sicheren Startwert gesetzt."""

    if os.path.exists(SAVE_FILE):
        try:
            with open(SAVE_FILE, "r") as f:
                content = f.read().strip()
                if content == "":
                    print("WARNUNG: FremdAPI_last.json ist leer → neue Struktur wird erzeugt.")
                else:
                    smartmeter_state = json.loads(content)

                    # Datei vorhanden & lesbar → energy_last_total korrekt initialisieren
                    if smartmeter_state.get("energy_last_total", 0) < energy_initial_total:

                        print(f"energy_last_total aktualisiert auf Initialwert {energy_initial_total}")
                        smartmeter_state["energy_last_total"] = energy_initial_total

                    # alle Smartmeter in richtige Struktur bringen
                    structure_corrected = False
                    for smartmeter_name in smartmeter_devices:
                        if smartmeter_name not in smartmeter_state or not isinstance(smartmeter_state.get(smartmeter_name), dict):
                            print(f"{smartmeter_name}: alte oder ungültige Struktur → wird neu initialisiert.")
                            smartmeter_state[smartmeter_name] = {
                                "power_last": 0,      # letzter gültiger Leistungswert
                                "energy_calc": 0, # berechnete Energiesumme
                                "energy_last2": 0,      # letzter echter Zählerstand
                                "stale_count": 0    # unverändert-Zähler
                            }
                            structure_corrected = True

                    if structure_corrected:
                        print("Strukturfehler korrigiert – State wurde überarbeitet.")

                    return smartmeter_state

        except Exception as e:
            print(f"WARNUNG: JSON defekt ({e}) → neue Struktur wird erzeugt.")

    # Datei fehlt oder defekt → komplett neuer State
    print("Erzeuge neuen State...")
    smartmeter_state = {
        smartmeter_name: {
            "power_last": 0,
            "energy_calc": 0,
            "energy_last2": 0,
            "stale_count": 0
        }
        for smartmeter_name in smartmeter_devices
    }
    smartmeter_state["energy_last_total"] = energy_initial_total
    print(f"energy_last_total initial auf {energy_initial_total} gesetzt.")
    return smartmeter_state


def save_state(smartmeter_state):
    try:
        with open(SAVE_FILE, "w") as f:
            json.dump(smartmeter_state, f, indent=4)
    except Exception:
        print("Fehler beim Speichern!")


def reset_counters(smartmeter_state):
    """Setzt die stale_count-Zähler täglich zwischen 00:05 und 00:25 zurück."""

    now = datetime.now()
    if now.hour == 0 and 5 <= now.minute <= 25:
        for smartmeter_name in smartmeter_devices:
            smartmeter_state[smartmeter_name]["stale_count"] = 0
        print("Tagesreset: stale_count auf 0 gesetzt.")


def try_direct_read(smartmeter_name, wait_seconds=20, attempt=1):
    """Versucht einen Direktabruf vom GEN24 (bis zu zwei Versuche).
       Gibt (sm_energy, sm_power) zurück oder (None, None) bei Fehlschlag."""

    if wait_seconds > 0:
        print(f"{smartmeter_name}: Warte {wait_seconds}s vor Direktabruf (Versuch {attempt})...")
        time.sleep(wait_seconds)

    smartmeter_map = extract_devices_struct(fetch_gen24_data())

    try:
        # robuster Zugriff: falls device nicht vorhanden -> KeyError -> except
        channels = smartmeter_map[smartmeter_name]["channels"]

        sm_energy_raw = channels.get("SMARTMETER_ENERGYACTIVE_PRODUCED_SUM_F64")
        sm_power_raw = channels.get("SMARTMETER_POWERACTIVE_MEAN_SUM_F64", 0)

        # Wenn sm_energy_raw None -> Fehler provozieren und except auslösen
        if sm_energy_raw is None:
            raise KeyError(f"{smartmeter_name}: fehlender Kanal SMARTMETER_ENERGYACTIVE_PRODUCED_SUM_F64")

        sm_energy = int(sm_energy_raw)
        sm_power = int(sm_power_raw)

        print(f"{smartmeter_name}: Direktabruf erfolgreich (Versuch {attempt})")
        return sm_energy, sm_power

    except Exception as e:
        print(f"{smartmeter_name}: Direktabruf fehlgeschlagen (Versuch {attempt}) → {e}")
        return None, None


# ------------------------- Hauptfunktion -------------------------

def get_API(data_temp):
    smartmeter_state = load_state()
    reset_counters(smartmeter_state)
    now = datetime.now()

    power_total = 0
    energy_total = 0

    # Geräte aus der übergebenen Struktur extrahieren (robust gegenüber unterschiedlichen Formen)
    smartmeter_map = extract_devices_struct(data_temp)

    for smartmeter_name in smartmeter_devices:
        sm_state = smartmeter_state[smartmeter_name]

        # ----------- Zugriff auf übergebene Data-Struktur -----------
        try:
            smartmeter_datastructure = smartmeter_map.get(smartmeter_name, {})
            channels = smartmeter_datastructure.get("channels", {}) if isinstance(smartmeter_datastructure, dict) else {}
        except Exception as e:
            print(f"{smartmeter_name}: Strukturfehler in externer Data → {e}")
            channels = {}
        # -------------------------------------------------------------

        # Werte einlesen
        sm_power = None
        sm_energy = None

        # ---------- Daten lesen ----------
        try:
            # Leistung — falls nicht vorhanden, bleibt None
            sm_power_raw = channels.get("SMARTMETER_POWERACTIVE_MEAN_SUM_F64", None)
            if sm_power_raw is not None:
                sm_power = int(sm_power_raw)
        except Exception:
            sm_power = None

        try:
            # Energie — exakter Key erwartet; wenn fehlt -> None
            sm_energy_raw = channels.get("SMARTMETER_ENERGYACTIVE_PRODUCED_SUM_F64", None)
            if sm_energy_raw is not None:
                sm_energy = int(sm_energy_raw)
        except Exception:
            sm_energy = None

        # Wenn Summe fehlt → Direktabruf GEN24 (max. 2 Versuche)
        if sm_energy is None:
            sm_energy, sm_power = try_direct_read(smartmeter_name, wait_seconds=20, attempt=1)
        if sm_energy is None:
            sm_energy, sm_power = try_direct_read(smartmeter_name, wait_seconds=20, attempt=2)

        # Wenn immer noch kein Wert → Fallback auf gespeicherten State
        if sm_energy is None:
            print(f"{smartmeter_name}: Fallback genutzt – alte Werte.")
            sm_energy = sm_state.get("energy_last2", 0)
            sm_power = sm_state.get("power_last", 0)

        # ---------- Erste Initialisierung ----------
        if sm_state["energy_calc"] == 0 and sm_state["energy_last2"] == 0:
            print(f"{smartmeter_name}: Erste Initialisierung → {sm_energy}")
            sm_state["energy_calc"] = sm_energy
            sm_state["energy_last2"] = sm_energy

        # ---------- Stale Detection ----------
        if sm_energy == sm_state["energy_last2"] and 8 <= now.hour < 18:
            sm_state["stale_count"] += 1
            print(f"{smartmeter_name}: unverändert, Zähler = {sm_state['stale_count']}")
            # sm_power kann 0 sein; Division int ok
            sm_energy = int(sm_state["energy_calc"] + (sm_power or 0) / 8)
            sm_state["energy_calc"] = sm_energy

        # ---------- Prüfung Power ----------
        if sm_power is not None and 0 <= sm_power < Leistung_WR:
            sm_state["power_last"] = sm_power
        else:
            print(f"{smartmeter_name}: Fehler Produktionswert ({sm_power}), nutze alten Wert.")
            sm_power = sm_state["power_last"]

        # ---------- Prüfung Summe----------
        if Summenpruefung_aktiv:
            min_val = min(sm_state["energy_calc"], sm_state["energy_last2"])
            max_val = max(sm_state["energy_calc"], sm_state["energy_last2"])

            if min_val <= sm_energy <= (max_val + Leistung_WR * 2):
                sm_state["energy_last2"] = sm_energy
            elif (min_val - 800) <= sm_energy:
                sm_energy = int(max_val)
            else:
                old = sm_energy
                sm_energy = int(max_val + sm_state["power_last"] / 8)
                print(f"{smartmeter_name}: Fehler Summenwert ({old}) → Fallback {sm_energy}")

        # ---------- energy_berechnet aktualisieren ----------
        if sm_energy > sm_state["energy_calc"]:
            sm_state["energy_calc"] = sm_energy

        power_total += sm_power
        energy_total += sm_energy

# ---------------------- Gesamt-Sicherheitslogik ----------------------

    energy_last_total = smartmeter_state.get("energy_last_total", 0)
    if Summenpruefung_aktiv:
        if energy_last_total == 0:
            print(f"Erster Start → energy_last_total = {energy_total}")

        elif energy_total < energy_last_total:
            print(f"⚠️ Gesamtenergie rückläufig ({energy_total} < {energy_last_total}) → nutze alten Wert.")
            energy_total = energy_last_total

        # ----------- Tagesgrenze (Max_Energiesprung_Tag) -----------
        elif Max_Energiesprung_Tag > 0 and energy_total > energy_last_total + 32000:
            diff = energy_total - energy_last_total
            print(f"⚠️ Gesamtenergie-Sprung viel zu groß (+{diff} Wh, maximal erlaubt +{Max_Energiesprung_Tag} Wh) → verworfen.")
            energy_total = energy_last_total

        # ----------- Einzelabrufgrenze (Max_Energiesprung) -----------
        elif Max_Energiesprung > 0 and energy_total > energy_last_total + 1600:
            diff = energy_total - energy_last_total
            print(
                f"⚠️ Gesamtenergie-Sprung moderat groß (+{diff} Wh, maximal erlaubt +{Max_Energiesprung} Wh) "
                f"→ begrenzt auf +{Max_Energiesprung} Wh."
            )
            energy_total = energy_last_total + 1600

    smartmeter_state["energy_last_total"] = energy_total
    save_state(smartmeter_state)

    # ---------------------- Ausgabe ----------------------

    if energy_initial_total > energy_total:
        energy_total=energy_initial_total
        print(f"⚠️ Datenfehler: AC_Produktion aktualisiert auf Initialwert {energy_initial_total}")
        print(f"⚠️ Bitte Summenpruefung in den Einstellungen aktivieren")
        print(f"Eine kleine Hilfe ist am Ende des Fremd_API Skriptes")

    Fremd_API = {
        "aktuellePVProduktion": power_total,
        "AC_Produktion": energy_total,
        "DC_Produktion": int(energy_total * 1.05)
    }

    print("\nGesamtProduktionSM:", Fremd_API["aktuellePVProduktion"])
    print("GesamtEnergieSM:", Fremd_API["AC_Produktion"], "\n")

    return Fremd_API
"""
Empfehlungen bei Verbindungsproblemen:

Die Standard-Einstellung der OpenDTU sollte sein, dass diese nur sendet,
wenn alle Wechselrichter der DTU eine aktive Verbindung haben.
--> unter Netzwerkeinstellungen->Modbus-Einstellungen:
Modbus TCP Server aktivieren:     aktiv (blau)
Modbus TCP Serverstart verzögern: aktiv (blau)

Falls ein Wechselrichter nicht erreichbar ist, liefert die DTU keine neuen Daten an den Fronius.
Dadurch können positive Energiesprünge entstehen, welche mittels "Max_Energiesprung" begrenzt werden

Bei mir kam es ebenfalls vor, dass die DTU beim Neustart zu wenig bisher produzierte Energie
an den Fronius übertragen hat, was in der Historie für Chaos gesorgt hatte.

Im Zweifelsfall schalte ich den GEN24 kurz ab (oder trenne ihn vom Netzwerk).
Solange der GEN24 offline ist, erhält er keine (fehlerhaften) Daten der DTU.
Wenn die DTU und alle Wechselrichter wieder stabil laufen, kann der GEN24 wieder online gehen.

Die Sendeleistung der DTU zu verändern brachte bei mir nur geringfügige Verbesserungen.
Viel entscheidender waren die Positionierung der DTU und die Ausrichtung der Antenne.

Bei mehr als drei Wechselrichtern an einer DTU empfehle ich eine zweite DTU.
Die Kosten sind überschaubar und die Auswirkungen von Datenverlusten halbieren sich.

Die vielen Sicherheitsmechanismen stammen aus der alten GEN24-Firmware (1.38),
bei der der GEN24 teilweise zusätzliche Smartmeter „erfunden“ hat.
Manchmal hat er sogar die beiden IDs vertauscht oder die Werte eines Smartmeters unter beiden IDs ausgegeben.
Damit daraus dennoch eine korrekte Historie entsteht, wurden alle diese Schutzmechanismen eingeführt.

Vielen Dank insbesondere an Wiggal:
https://github.com/wiggal/
"""






